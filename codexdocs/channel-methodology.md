# 채널 협업 방법론 (Viblack)

이 문서는 Viblack 프로젝트에서 "채널"이 다중 AI 에이전트 협업을 유기적으로 지원하도록 하기 위한 운영 방법론이다. 구현 지침이 아니라, 현재 코드베이스의 구조를 존중하면서 팀 운영/메시지 규약/협업 흐름을 합의하기 위한 원칙과 규칙을 정의한다.

## 1) 현재 상태 요약 (근거)
- `src/backend/server.ts`: 에이전트별 직렬 실행을 위해 `withAgentLock` 사용. 같은 에이전트는 동시 실행 금지.
- `src/backend/db.ts`: agents/messages 테이블만 존재. 채널 데이터는 아직 백엔드 저장 없음.
- `src/renderer/renderer.ts`: `channels[]`, `activeChannelId`, 멤버 관리 UI가 있으나 채널 대화는 비활성화됨.
- `README.md`: DM 기반 흐름(단일 에이전트)과 `codex exec`/`resume` 세션 유지 방식 명시.
- `codexdocs/Idea.md`, `codexdocs/idea_plan.md`: 채널은 다자 협업 공간으로 정의됨.

## 2) 채널 정의
채널은 "다중 에이전트가 동일한 목표/과업을 공유하는 협업 공간"이다.
- 목적 중심: 목표, 업무 범위, 의사결정 기록이 남아야 한다.
- 멤버 기반: 채널에 소속된 에이전트만 참여하고, 역할이 구분된다.
- 메시지 기반: 업무 지시/상태 공유/결과 공유가 채널 로그에 축적된다.

## 3) 핵심 원칙
1. 에이전트는 "세션 상태"를 가진다. 같은 에이전트는 동시에 실행하지 않는다.
2. 채널은 "협업 맥락"을 제공하되, 실행은 "에이전트 단위"로 직렬화한다.
3. DM과 채널의 책임은 분리한다. DM은 개인 작업, 채널은 팀 작업.
4. 결과물은 채널 로그에 남긴다. 검토/결정/근거를 메시지로 남기는 것을 원칙으로 한다.
5. 메시지는 가능한 한 구조화한다. (요청/결과/상태를 명확히 구분)
6. 채널 내부에서 "중심 역할"을 찾아 협업 흐름을 형성한다.

## 4) 기본 역할 예시
채널은 역할 분리로 협업 흐름을 명확히 한다. 아래는 고정 카테고리가 아닌 예시다.
- 오너(Owner): 목표 정의, 우선순위 결정, 최종 승인.
- 실행(Executor): 실제 작업 수행 및 결과 보고.
- 리뷰(Reviewer): 결과 검토, 결함/리스크 지적.
- 기록(Recorder): 요약/결정사항 정리, 합의 업데이트.

작업 시작 시 각 에이전트는 자신의 역할을 채널 상단 또는 첫 메시지에 선언한다.

## 4.1) 역할은 고정 카테고리가 아님
- 역할/시스템 프롬프트는 사용자가 직접 정의한다.
- 에이전트 간 멘션/협업은 "사용자 정의 역할 설명"을 근거로 자율적으로 이루어진다.
- 따라서 채널은 사전 정의된 직군 대신, 각 에이전트의 역할 선언/프롬프트를 기준으로 협업한다.

## 4.2) 연구 근거: 사용자 정의 역할에서의 라우팅 원칙
- 역할은 "정체성"이 아니라 "역량 프로필"로 다루는 것이 학술/OSS 공통 결론.
- 역할 정의(프로필)과 역할 배정(라우팅)을 분리하라는 권고가 다수 문헌에 등장.
- 명시적 핸드오프(전달)는 반드시 감사/추적 가능해야 함.

참고:
- Contract Net Protocol: 역할은 작업 상대적으로 동적 (Smith, 1980) https://doi.org/10.1109/TC.1980.1675516
- Blackboard: 역할은 트리거 조건 기반 (Nii, 1986) https://doi.org/10.1609/aimag.v7i2.537
- 사용자 정의 역할의 동적 배정 효율 (Zhang et al., 2026) https://arxiv.org/abs/2601.17152
- Handoff를 1급 연산으로 취급 (OpenAI Cookbook) https://developers.openai.com/cookbook/examples/orchestrating_agents/

## 5) 메시지 규약 (채널 운영 포맷)
채널 메시지는 다음 4종으로 구분한다.

### (A) 요청 메시지
```
[요청]
- 목표: ...
- 범위: ...
- 기대 산출물: ...
- 마감: ...
- 참고: ...
```

### (B) 진행/상태 메시지
```
[진행]
- 상태: 준비 | 진행중 | 막힘 | 완료
- 이번 작업: ...
- 다음 액션: ...
- 리스크/질문: ...
```

### (C) 결과 메시지
```
[결과]
- 요약: ...
- 산출물: ...
- 근거/링크: ...
- 다음 제안: ...
```

### (D) 재멘션 요청 메시지
```
[재멘션 요청]
- 요청 내용: ...
- 사유: (역할 범위 밖/도구 미지원/권한 없음 등)
- 제안 대상: @agent-name
```

## 6) 멘션 규칙 (호출/할당)
- `@agent-name` 멘션은 "명시적 호출"로 본다.
- 채널 공지성 메시지는 멘션 없이 "브로드캐스트"로 처리한다.
- 멘션 받은 에이전트는 1회 이상 진행/결과 메시지로 응답해야 한다.

## 6.1) 멘션 없는 메시지 처리 (확정)
- 확정: 옵션 B (채널 기록만 하고, 명시적 멘션이 있을 때만 작업 실행)

선택 근거:
- 브로드캐스트 기본값은 중복 응답/소음을 유발하고 책임 소재가 흐려짐.
- 명시적 멘션 기반이 현재 구조(에이전트별 직렬 실행)에 가장 안정적으로 부합.

### 운영 원칙
- 멘션 없는 메시지는 채널 로그에만 기록한다.
- 작업 실행은 명시적 멘션이 있을 때만 발생한다.
- 브로드캐스트는 "공지/상태 공유" 성격의 메시지로 제한한다.
- 멘션 없는 메시지는 응답 의무가 없다.

## 6.2) 외부 OSS/방법론 근거 (멘션 없는 메시지 처리)
다중 에이전트 OSS는 "무멘션 메시지"를 다음 4가지로 처리한다.

1) Pub/Sub 브로드캐스트 + 구독 옵트인 (AutoGen Core)
- 주제(Topic) 기반으로 모든 구독자에게 팬아웃. 수신자는 응답 여부를 자율 결정.
- 장점: 단순/확장성. 단점: 중복 응답/소음 가능.
- 근거: `autogen-core`의 `publish_message` + `SubscriptionManager` 팬아웃 구조.

2) LLM 기반 라우터/셀렉터 (AutoGen SelectorGroupChat)
- 메타 라우터가 대화 히스토리를 읽고 "다음 화자" 1명을 선택.
- 장점: 유연한 라우팅. 단점: 매 턴 LLM 비용/지연.

3) 기본 담당자 + 명시적 핸드오프 (AutoGen Swarm)
- 무멘션 메시지는 기본 담당자(첫 참가자/리드)에게 전달.
- 이후 `Handoff` 메시지로 다음 담당자 명시.
- 장점: 결정적/저비용. 단점: 리드 에이전트의 라우팅 품질 의존.

4) 조건부 라우터 함수 (LangGraph)
- 메시지/상태를 검사하는 라우터 함수가 다음 노드를 선택.
- 장점: 규칙 기반, 비용 낮음. 단점: 규칙 유지보수 필요.

## 6.3) 권장 운영안 (사용자 정의 역할 기준)
1) 역할 프로필(간단 소개) 저장/공개
- 역할 프로필은 멤버 정보에 저장한다.
- 채널에서는 필요 시 멤버 정보에서 역할 프로필을 확인하고 멘션한다.
- 역할은 자유 형식이지만, "무엇을 잘하는지/하지 못하는지"를 반드시 포함.
- 에이전트가 서로의 역할 프로필을 조회할 수 있어야 한다.
- 조회 범위는 "같은 채널 멤버"로 제한한다.

2) 멘션은 명시적 배정만 허용
- 무멘션 메시지는 로그로만 기록 (응답 의무 없음).
- 작업 실행은 멘션된 에이전트만 수행.

3) 멘션 기준은 역할 프로필과 일치해야 함
- 멘션 주체는 사용자 또는 채널 내 합의된 중심 역할/담당자.
- 에이전트는 본인 역할 범위를 벗어난 요청을 받으면 "재멘션 요청"으로 반환.

4) 핸드오프는 메시지로 명시
- 다른 에이전트를 호출해야 할 때는 "이유 + 대상"을 명시하고 멘션.
- 멘션 없이 내부적으로 넘기는 행위는 금지.

근거:
- 역할 정의/배정 분리: Contract Net, Dynamic Role Assignment
- 명시적 핸드오프: OpenAI Agents SDK/Swarm 패턴

## 7) 실행/동시성 규칙 (현 구조 반영)
현재 구조를 기준으로 다음을 기본 규칙으로 삼는다.
- 같은 에이전트는 동시에 두 작업을 실행하지 않는다. (`withAgentLock` 원칙)
- 서로 다른 에이전트는 병렬로 실행 가능하다.
- 채널 내 메시지는 "실행 대상"(멘션)을 명확히 하고, 실행 결과를 채널에 다시 공유한다.

## 8) 채널 협업 흐름 (권장 시나리오)
### 8.1) 중심 역할 합의 절차
1. 채널 멤버들이 역할 프로필을 바탕으로 중심 역할 후보를 제안한다.
2. 후보 제안 메시지에 동의 멘션을 남겨 합의한다.
3. 가장 많은 동의를 받은 1인을 중심 역할로 확정한다.

### 8.2) 범용 시나리오 (역할 중립)
1. 중심 역할이 목표/범위를 공지한다. (요청 메시지)
2. 설계/기획 성격의 역할이 계획을 공유하고 중심 역할을 멘션한다.
3. 중심 역할이 실행 역할들을 멘션해 작업을 할당한다.
4. 실행 역할은 완료 메시지를 채널에 남긴다.
4-1. 진행 중 블로킹 발생 시 [진행] 상태를 "막힘"으로 올리고 중심 역할을 멘션한다.
5. 검증/테스트 성격의 역할이 결과를 확인하고 리포트를 남긴다.
6. 중심 역할이 결과를 종합해 사용자에게 보고한다.

## 9) 충돌/중복 방지 규칙
- 동일 작업이 중복되는 경우, 중심 역할 또는 채널 합의된 담당자가 1인을 지정한다.
- 작업 충돌이 예상되면 "작업 범위"를 분해해 병렬화한다.
- 동일 에이전트에 대한 동시 요청이 발생하면 순서를 지정한다.

## 10) 작업 기록/추적 원칙
- 중요한 결론/의사결정은 반드시 채널 로그에 남긴다.
- 리뷰 결과(승인/반려)와 이유를 채널에 남긴다.
- 일정/우선순위 변경도 채널에서 공지한다.

## 11) 현재 제약사항 (프로덕트 현실 반영)
- 채널 메시징은 아직 백엔드에 구현되지 않았다.
- 현재는 DM 중심으로만 메시지가 저장/실행된다.
- 따라서 채널 운영은 "정책/규칙" 중심으로 먼저 정립하고, 구현은 이후 단계로 본다.
- 구현 예정 이슈/PR: [TBD]

## 12) 운영 체크리스트
- [ ] 채널 목적/범위가 첫 메시지에 명시되었는가
- [ ] 각 에이전트의 역할이 선언되었는가
- [ ] 작업 요청이 구조화 메시지로 작성되었는가
- [ ] 진행/결과 보고가 채널 로그에 남았는가
- [ ] 리뷰/결정 사항이 명시되었는가

## 13) 파일 근거
- `src/backend/server.ts`: 에이전트별 직렬 실행 및 메시지 라우팅 근거
- `src/backend/db.ts`: 메시지/에이전트 데이터 모델 근거
- `src/renderer/renderer.ts`: 채널 UI 상태 및 멤버 관리 근거
- `codexdocs/Idea.md`: 채널의 협업 목적 정의
- `codexdocs/idea_plan.md`: 채널 협업 시나리오/요구사항 근거
